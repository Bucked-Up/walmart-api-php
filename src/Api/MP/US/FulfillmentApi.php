<?php

/**
 * FulfillmentApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 */

/**
 * Fulfillment Management
 *
 * This class is auto-generated by the OpenAPI generator v6.6.0 (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace Walmart\Api\MP\US;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use Walmart\Api\BaseApi;
use Walmart\ApiException;
use Walmart\ObjectSerializer;

require_once __DIR__ . '/../../../../vendor/autoload.php';

/**
 * FulfillmentApi Class Doc Comment
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 * @email    jesse@highsidelabs.co
 */
class FulfillmentApi extends BaseApi
{
    /**
     * @var string[] $contentTypes
     */
    public const contentTypes = [
        'cancelFulfillment' => 'application/json',
        'cancelShipment' => 'application/json',
        'confirmCarrierRateQuote' => 'application/json',
        'convertItemForWfs' => 'application/json',
        'createCarrierRateQuotes' => 'application/json',
        'createFulfillment' => 'application/json',
        'createInboundShipmentLabel' => 'application/json',
        'createInboundShipmentLabelV2' => 'application/json',
        'createShipment' => 'application/json',
        'getCarrierRateQuote' => 'application/json',
        'getFulfillmentOrdersStatus' => 'application/json',
        'getInboundOrderErrors' => 'application/json',
        'getInboundShipmentItems' => 'application/json',
        'getInboundShipments' => 'application/json',
        'getInventoryHealthReport' => 'application/json',
        'getWFSInventoryLog' => 'application/json',
        'inboundPreview' => 'application/json',
        'printCarrierLabel' => 'application/json',
        'promiseFulfillments' => 'application/json',
        'updateShipmentQuantity' => 'application/json',
        'updateShipmentTrackingDetails' => 'application/json',
        'voidCarrierRateQuote' => 'application/json',
        'wercsFeedback' => 'application/json',
    ];

    /**
     * Operation cancelFulfillment
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response
     */
    public function cancelFulfillment(
        \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest
    ): \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response {
        return $this->cancelFulfillmentWithHttpInfo($cancelFulfillmentRequest);
    }

    /**
     * Operation cancelFulfillmentWithHttpInfo
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response
     */
    protected function cancelFulfillmentWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest,
    ): \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response {
        $request = $this->cancelFulfillmentRequest($cancelFulfillmentRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation cancelFulfillmentAsync
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelFulfillmentAsync(
        \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest
    ): PromiseInterface {
        return $this->cancelFulfillmentAsyncWithHttpInfo($cancelFulfillmentRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelFulfillmentAsyncWithHttpInfo
     *
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function cancelFulfillmentAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response';
        $request = $this->cancelFulfillmentRequest($cancelFulfillmentRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelFulfillment'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelFulfillmentRequest(
        \Walmart\Model\MP\US\Fulfillment\CancelFulfillmentRequest $cancelFulfillmentRequest,
    ): Request {
        $contentType = self::contentTypes['cancelFulfillment'];

        // verify the required parameter 'cancelFulfillmentRequest' is set
        if ($cancelFulfillmentRequest === null || (is_array($cancelFulfillmentRequest) && count($cancelFulfillmentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cancelFulfillmentRequest when calling cancelFulfillment'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cancelFulfillmentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cancelFulfillmentRequest));
            } else {
                $httpBody = $cancelFulfillmentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelShipment
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    public function cancelShipment(
        string $inboundOrderId
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        return $this->cancelShipmentWithHttpInfo($inboundOrderId);
    }

    /**
     * Operation cancelShipmentWithHttpInfo
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    protected function cancelShipmentWithHttpInfo(
        string $inboundOrderId,
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        $request = $this->cancelShipmentRequest($inboundOrderId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation cancelShipmentAsync
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelShipmentAsync(
        string $inboundOrderId
    ): PromiseInterface {
        return $this->cancelShipmentAsyncWithHttpInfo($inboundOrderId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelShipmentAsyncWithHttpInfo
     *
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function cancelShipmentAsyncWithHttpInfo(
        string $inboundOrderId,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
        $request = $this->cancelShipmentRequest($inboundOrderId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelShipment'
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelShipmentRequest(
        string $inboundOrderId,
    ): Request {
        $contentType = self::contentTypes['cancelShipment'];

        // verify the required parameter 'inboundOrderId' is set
        if ($inboundOrderId === null || (is_array($inboundOrderId) && count($inboundOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inboundOrderId when calling cancelShipment'
            );
        }
        $resourcePath = '/v3/fulfillment/inbound-shipments/{inboundOrderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($inboundOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'inboundOrderId' . '}',
                ObjectSerializer::toPathValue($inboundOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation confirmCarrierRateQuote
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    public function confirmCarrierRateQuote(
        \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        return $this->confirmCarrierRateQuoteWithHttpInfo($confirmCarrierRateQuoteRequest);
    }

    /**
     * Operation confirmCarrierRateQuoteWithHttpInfo
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    protected function confirmCarrierRateQuoteWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest,
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        $request = $this->confirmCarrierRateQuoteRequest($confirmCarrierRateQuoteRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation confirmCarrierRateQuoteAsync
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmCarrierRateQuoteAsync(
        \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest
    ): PromiseInterface {
        return $this->confirmCarrierRateQuoteAsyncWithHttpInfo($confirmCarrierRateQuoteRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation confirmCarrierRateQuoteAsyncWithHttpInfo
     *
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function confirmCarrierRateQuoteAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
        $request = $this->confirmCarrierRateQuoteRequest($confirmCarrierRateQuoteRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'confirmCarrierRateQuote'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function confirmCarrierRateQuoteRequest(
        \Walmart\Model\MP\US\Fulfillment\ConfirmCarrierRateQuoteRequest $confirmCarrierRateQuoteRequest,
    ): Request {
        $contentType = self::contentTypes['confirmCarrierRateQuote'];

        // verify the required parameter 'confirmCarrierRateQuoteRequest' is set
        if ($confirmCarrierRateQuoteRequest === null || (is_array($confirmCarrierRateQuoteRequest) && count($confirmCarrierRateQuoteRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $confirmCarrierRateQuoteRequest when calling confirmCarrierRateQuote'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quote/confirm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($confirmCarrierRateQuoteRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($confirmCarrierRateQuoteRequest));
            } else {
                $httpBody = $confirmCarrierRateQuoteRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation convertItemForWfs
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response
     */
    public function convertItemForWfs(
        string $feedType,
        ?\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest = null
    ): \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response {
        return $this->convertItemForWfsWithHttpInfo($feedType, $convertItemForWfsRequest);
    }

    /**
     * Operation convertItemForWfsWithHttpInfo
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response
     */
    protected function convertItemForWfsWithHttpInfo(
        string $feedType,
        ?\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest = null,
    ): \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response {
        $request = $this->convertItemForWfsRequest($feedType, $convertItemForWfsRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation convertItemForWfsAsync
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertItemForWfsAsync(
        string $feedType,
        ?\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest = null
    ): PromiseInterface {
        return $this->convertItemForWfsAsyncWithHttpInfo($feedType, $convertItemForWfsRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation convertItemForWfsAsyncWithHttpInfo
     *
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function convertItemForWfsAsyncWithHttpInfo(
        string $feedType,
        ?\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfs200Response';
        $request = $this->convertItemForWfsRequest($feedType, $convertItemForWfsRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'convertItemForWfs'
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function convertItemForWfsRequest(
        string $feedType,
        ?\Walmart\Model\MP\US\Fulfillment\ConvertItemForWfsRequest $convertItemForWfsRequest = null,
    ): Request {
        $contentType = self::contentTypes['convertItemForWfs'];

        // verify the required parameter 'feedType' is set
        if ($feedType === null || (is_array($feedType) && count($feedType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feedType when calling convertItemForWfs'
            );
        }
        $resourcePath = '/v3/feeds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = [
            ObjectSerializer::toQueryValue(
                $feedType,
                'feedType', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
        ];

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($convertItemForWfsRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($convertItemForWfsRequest));
            } else {
                $httpBody = $convertItemForWfsRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCarrierRateQuotes
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response
     */
    public function createCarrierRateQuotes(
        \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest
    ): \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response {
        return $this->createCarrierRateQuotesWithHttpInfo($createCarrierRateQuotesRequest);
    }

    /**
     * Operation createCarrierRateQuotesWithHttpInfo
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response
     */
    protected function createCarrierRateQuotesWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest,
    ): \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response {
        $request = $this->createCarrierRateQuotesRequest($createCarrierRateQuotesRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createCarrierRateQuotesAsync
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCarrierRateQuotesAsync(
        \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest
    ): PromiseInterface {
        return $this->createCarrierRateQuotesAsyncWithHttpInfo($createCarrierRateQuotesRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCarrierRateQuotesAsyncWithHttpInfo
     *
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createCarrierRateQuotesAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotes200Response';
        $request = $this->createCarrierRateQuotesRequest($createCarrierRateQuotesRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCarrierRateQuotes'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCarrierRateQuotesRequest(
        \Walmart\Model\MP\US\Fulfillment\CreateCarrierRateQuotesRequest $createCarrierRateQuotesRequest,
    ): Request {
        $contentType = self::contentTypes['createCarrierRateQuotes'];

        // verify the required parameter 'createCarrierRateQuotesRequest' is set
        if ($createCarrierRateQuotesRequest === null || (is_array($createCarrierRateQuotesRequest) && count($createCarrierRateQuotesRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createCarrierRateQuotesRequest when calling createCarrierRateQuotes'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createCarrierRateQuotesRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createCarrierRateQuotesRequest));
            } else {
                $httpBody = $createCarrierRateQuotesRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFulfillment
     *
     * Create Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response
     */
    public function createFulfillment(
        \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest
    ): \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response {
        return $this->createFulfillmentWithHttpInfo($createFulfillmentRequest);
    }

    /**
     * Operation createFulfillmentWithHttpInfo
     *
     * Create Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response
     */
    protected function createFulfillmentWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest,
    ): \Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response {
        $request = $this->createFulfillmentRequest($createFulfillmentRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createFulfillmentAsync
     *
     * Create Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFulfillmentAsync(
        \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest
    ): PromiseInterface {
        return $this->createFulfillmentAsyncWithHttpInfo($createFulfillmentRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFulfillmentAsyncWithHttpInfo
     *
     *
     * Create Customer Order
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createFulfillmentAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateFulfillment200Response';
        $request = $this->createFulfillmentRequest($createFulfillmentRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFulfillment'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFulfillmentRequest(
        \Walmart\Model\MP\US\Fulfillment\CreateFulfillmentRequest $createFulfillmentRequest,
    ): Request {
        $contentType = self::contentTypes['createFulfillment'];

        // verify the required parameter 'createFulfillmentRequest' is set
        if ($createFulfillmentRequest === null || (is_array($createFulfillmentRequest) && count($createFulfillmentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createFulfillmentRequest when calling createFulfillment'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createFulfillmentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createFulfillmentRequest));
            } else {
                $httpBody = $createFulfillmentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInboundShipmentLabel
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function createInboundShipmentLabel(
        string $shipmentId
    ): string {
        return $this->createInboundShipmentLabelWithHttpInfo($shipmentId);
    }

    /**
     * Operation createInboundShipmentLabelWithHttpInfo
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    protected function createInboundShipmentLabelWithHttpInfo(
        string $shipmentId,
    ): string {
        $request = $this->createInboundShipmentLabelRequest($shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createInboundShipmentLabelAsync
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInboundShipmentLabelAsync(
        string $shipmentId
    ): PromiseInterface {
        return $this->createInboundShipmentLabelAsyncWithHttpInfo($shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInboundShipmentLabelAsyncWithHttpInfo
     *
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createInboundShipmentLabelAsyncWithHttpInfo(
        string $shipmentId,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->createInboundShipmentLabelRequest($shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInboundShipmentLabel'
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createInboundShipmentLabelRequest(
        string $shipmentId,
    ): Request {
        $contentType = self::contentTypes['createInboundShipmentLabel'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling createInboundShipmentLabel'
            );
        }
        $resourcePath = '/v3/fulfillment/label/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInboundShipmentLabelV2
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function createInboundShipmentLabelV2(
        \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request
    ): string {
        return $this->createInboundShipmentLabelV2WithHttpInfo($createInboundShipmentLabelV2Request);
    }

    /**
     * Operation createInboundShipmentLabelV2WithHttpInfo
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    protected function createInboundShipmentLabelV2WithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request,
    ): string {
        $request = $this->createInboundShipmentLabelV2Request($createInboundShipmentLabelV2Request, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createInboundShipmentLabelV2Async
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInboundShipmentLabelV2Async(
        \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request
    ): PromiseInterface {
        return $this->createInboundShipmentLabelV2AsyncWithHttpInfo($createInboundShipmentLabelV2Request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInboundShipmentLabelV2AsyncWithHttpInfo
     *
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createInboundShipmentLabelV2AsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->createInboundShipmentLabelV2Request($createInboundShipmentLabelV2Request, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInboundShipmentLabelV2'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createInboundShipmentLabelV2Request(
        \Walmart\Model\MP\US\Fulfillment\CreateInboundShipmentLabelV2Request $createInboundShipmentLabelV2Request,
    ): Request {
        $contentType = self::contentTypes['createInboundShipmentLabelV2'];

        // verify the required parameter 'createInboundShipmentLabelV2Request' is set
        if ($createInboundShipmentLabelV2Request === null || (is_array($createInboundShipmentLabelV2Request) && count($createInboundShipmentLabelV2Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createInboundShipmentLabelV2Request when calling createInboundShipmentLabelV2'
            );
        }
        $resourcePath = '/v3/fulfillment/shipment-label';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createInboundShipmentLabelV2Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createInboundShipmentLabelV2Request));
            } else {
                $httpBody = $createInboundShipmentLabelV2Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createShipment
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateShipment200Response
     */
    public function createShipment(
        \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest
    ): \Walmart\Model\MP\US\Fulfillment\CreateShipment200Response {
        return $this->createShipmentWithHttpInfo($createShipmentRequest);
    }

    /**
     * Operation createShipmentWithHttpInfo
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\CreateShipment200Response
     */
    protected function createShipmentWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest,
    ): \Walmart\Model\MP\US\Fulfillment\CreateShipment200Response {
        $request = $this->createShipmentRequest($createShipmentRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\CreateShipment200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\CreateShipment200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\CreateShipment200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateShipment200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\CreateShipment200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createShipmentAsync
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentAsync(
        \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest
    ): PromiseInterface {
        return $this->createShipmentAsyncWithHttpInfo($createShipmentRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createShipmentAsyncWithHttpInfo
     *
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createShipmentAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\CreateShipment200Response';
        $request = $this->createShipmentRequest($createShipmentRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createShipment'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createShipmentRequest(
        \Walmart\Model\MP\US\Fulfillment\CreateShipmentRequest $createShipmentRequest,
    ): Request {
        $contentType = self::contentTypes['createShipment'];

        // verify the required parameter 'createShipmentRequest' is set
        if ($createShipmentRequest === null || (is_array($createShipmentRequest) && count($createShipmentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createShipmentRequest when calling createShipment'
            );
        }
        $resourcePath = '/v3/fulfillment/inbound-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createShipmentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createShipmentRequest));
            } else {
                $httpBody = $createShipmentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarrierRateQuote
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response
     */
    public function getCarrierRateQuote(
        string $shipmentId,
        string $mode
    ): \Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response {
        return $this->getCarrierRateQuoteWithHttpInfo($shipmentId, $mode);
    }

    /**
     * Operation getCarrierRateQuoteWithHttpInfo
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response
     */
    protected function getCarrierRateQuoteWithHttpInfo(
        string $shipmentId,
        string $mode,
    ): \Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response {
        $request = $this->getCarrierRateQuoteRequest($shipmentId, $mode, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getCarrierRateQuoteAsync
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierRateQuoteAsync(
        string $shipmentId,
        string $mode
    ): PromiseInterface {
        return $this->getCarrierRateQuoteAsyncWithHttpInfo($shipmentId, $mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarrierRateQuoteAsyncWithHttpInfo
     *
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getCarrierRateQuoteAsyncWithHttpInfo(
        string $shipmentId,
        string $mode,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\GetCarrierRateQuote200Response';
        $request = $this->getCarrierRateQuoteRequest($shipmentId, $mode, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarrierRateQuote'
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarrierRateQuoteRequest(
        string $shipmentId,
        string $mode,
    ): Request {
        $contentType = self::contentTypes['getCarrierRateQuote'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling getCarrierRateQuote'
            );
        }
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling getCarrierRateQuote'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }
        if ($mode !== null) {
            $resourcePath = str_replace(
                '{' . 'mode' . '}',
                ObjectSerializer::toPathValue($mode),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFulfillmentOrdersStatus
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response
     */
    public function getFulfillmentOrdersStatus(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null
    ): \Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response {
        return $this->getFulfillmentOrdersStatusWithHttpInfo($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy);
    }

    /**
     * Operation getFulfillmentOrdersStatusWithHttpInfo
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response
     */
    protected function getFulfillmentOrdersStatusWithHttpInfo(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null,
    ): \Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response {
        $request = $this->getFulfillmentOrdersStatusRequest($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getFulfillmentOrdersStatusAsync
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFulfillmentOrdersStatusAsync(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null
    ): PromiseInterface {
        return $this->getFulfillmentOrdersStatusAsyncWithHttpInfo($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFulfillmentOrdersStatusAsyncWithHttpInfo
     *
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getFulfillmentOrdersStatusAsyncWithHttpInfo(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\GetFulfillmentOrdersStatus200Response';
        $request = $this->getFulfillmentOrdersStatusRequest($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFulfillmentOrdersStatus'
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFulfillmentOrdersStatusRequest(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null,
    ): Request {
        $contentType = self::contentTypes['getFulfillmentOrdersStatus'];

        // verify the required parameter 'orgId' is set
        if ($orgId === null || (is_array($orgId) && count($orgId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orgId when calling getFulfillmentOrdersStatus'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling getFulfillmentOrdersStatus'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling getFulfillmentOrdersStatus'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = [
            ObjectSerializer::toQueryValue(
                $orgId,
                'orgId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $orderNumber,
                'orderNumber', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $trackingNumber,
                'trackingNumber', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentNumber,
                'shipmentNumber', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $fromOrderDate,
                'fromOrderDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $toOrderDate,
                'toOrderDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortOrder,
                'sortOrder', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortBy,
                'sortBy', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        ];

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundOrderErrors
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response
     */
    public function getInboundOrderErrors(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): \Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response {
        return $this->getInboundOrderErrorsWithHttpInfo($offset, $limit, $shipmentId);
    }

    /**
     * Operation getInboundOrderErrorsWithHttpInfo
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response
     */
    protected function getInboundOrderErrorsWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): \Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response {
        $request = $this->getInboundOrderErrorsRequest($offset, $limit, $shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInboundOrderErrorsAsync
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundOrderErrorsAsync(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): PromiseInterface {
        return $this->getInboundOrderErrorsAsyncWithHttpInfo($offset, $limit, $shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundOrderErrorsAsyncWithHttpInfo
     *
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInboundOrderErrorsAsyncWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\GetInboundOrderErrors200Response';
        $request = $this->getInboundOrderErrorsRequest($offset, $limit, $shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundOrderErrors'
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInboundOrderErrorsRequest(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): Request {
        $contentType = self::contentTypes['getInboundOrderErrors'];

        $resourcePath = '/v3/fulfillment/inbound-shipment-errors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = [
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        ];

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundShipmentItems
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response
     */
    public function getInboundShipmentItems(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): \Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response {
        return $this->getInboundShipmentItemsWithHttpInfo($offset, $limit, $shipmentId);
    }

    /**
     * Operation getInboundShipmentItemsWithHttpInfo
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response
     */
    protected function getInboundShipmentItemsWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): \Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response {
        $request = $this->getInboundShipmentItemsRequest($offset, $limit, $shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInboundShipmentItemsAsync
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundShipmentItemsAsync(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): PromiseInterface {
        return $this->getInboundShipmentItemsAsyncWithHttpInfo($offset, $limit, $shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundShipmentItemsAsyncWithHttpInfo
     *
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInboundShipmentItemsAsyncWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\GetInboundShipmentItems200Response';
        $request = $this->getInboundShipmentItemsRequest($offset, $limit, $shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundShipmentItems'
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInboundShipmentItemsRequest(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): Request {
        $contentType = self::contentTypes['getInboundShipmentItems'];

        $resourcePath = '/v3/fulfillment/inbound-shipment-items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = [
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        ];

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundShipments
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response
     */
    public function getInboundShipments(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null
    ): \Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response {
        return $this->getInboundShipmentsWithHttpInfo($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate);
    }

    /**
     * Operation getInboundShipmentsWithHttpInfo
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response
     */
    protected function getInboundShipmentsWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null,
    ): \Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response {
        $request = $this->getInboundShipmentsRequest($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInboundShipmentsAsync
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundShipmentsAsync(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null
    ): PromiseInterface {
        return $this->getInboundShipmentsAsyncWithHttpInfo($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundShipmentsAsyncWithHttpInfo
     *
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInboundShipmentsAsyncWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\GetInboundShipments200Response';
        $request = $this->getInboundShipmentsRequest($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundShipments'
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInboundShipmentsRequest(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null,
    ): Request {
        $contentType = self::contentTypes['getInboundShipments'];

        $resourcePath = '/v3/fulfillment/inbound-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = [
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $inboundOrderId,
                'inboundOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $status,
                'status', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $fromCreateDate,
                'fromCreateDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $toCreateDate,
                'toCreateDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        ];

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInventoryHealthReport
     *
     * Get WFS Inventory Health Report
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getInventoryHealthReport(): string
    {
        return $this->getInventoryHealthReportWithHttpInfo();
    }

    /**
     * Operation getInventoryHealthReportWithHttpInfo
     *
     * Get WFS Inventory Health Report
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    protected function getInventoryHealthReportWithHttpInfo(): string
    {
        $request = $this->getInventoryHealthReportRequest();
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInventoryHealthReportAsync
     *
     * Get WFS Inventory Health Report
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoryHealthReportAsync(
    ): PromiseInterface {
        return $this->getInventoryHealthReportAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInventoryHealthReportAsyncWithHttpInfo
     *
     *
     * Get WFS Inventory Health Report
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInventoryHealthReportAsyncWithHttpInfo(): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->getInventoryHealthReportRequest();
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInventoryHealthReport'
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInventoryHealthReportRequest(): Request
    {
        $contentType = self::contentTypes['getInventoryHealthReport'];

        $resourcePath = '/v3/report/wfs/getInventoryHealthReport';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWFSInventoryLog
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response
     */
    public function getWFSInventoryLog(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50'
    ): \Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response {
        return $this->getWFSInventoryLogWithHttpInfo($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit);
    }

    /**
     * Operation getWFSInventoryLogWithHttpInfo
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response
     */
    protected function getWFSInventoryLogWithHttpInfo(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50',
    ): \Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response {
        $request = $this->getWFSInventoryLogRequest($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getWFSInventoryLogAsync
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWFSInventoryLogAsync(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50'
    ): PromiseInterface {
        return $this->getWFSInventoryLogAsyncWithHttpInfo($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWFSInventoryLogAsyncWithHttpInfo
     *
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getWFSInventoryLogAsyncWithHttpInfo(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50',
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\GetWFSInventoryLog200Response';
        $request = $this->getWFSInventoryLogRequest($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWFSInventoryLog'
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWFSInventoryLogRequest(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50',
    ): Request {
        $contentType = self::contentTypes['getWFSInventoryLog'];

        // verify the required parameter 'gtin' is set
        if ($gtin === null || (is_array($gtin) && count($gtin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $gtin when calling getWFSInventoryLog'
            );
        }
        $resourcePath = '/v3/fulfillment/inventory-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = [
            ObjectSerializer::toQueryValue(
                $gtin,
                'gtin', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $transactionType,
                'transactionType', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $transactionLocation,
                'transactionLocation', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $startDate,
                'startDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $endDate,
                'endDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortBy,
                'sort_by', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortOrder,
                'sort_order', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        ];

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inboundPreview
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\InboundPreview200Response
     */
    public function inboundPreview(
        \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest
    ): \Walmart\Model\MP\US\Fulfillment\InboundPreview200Response {
        return $this->inboundPreviewWithHttpInfo($inboundPreviewRequest);
    }

    /**
     * Operation inboundPreviewWithHttpInfo
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\InboundPreview200Response
     */
    protected function inboundPreviewWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest,
    ): \Walmart\Model\MP\US\Fulfillment\InboundPreview200Response {
        $request = $this->inboundPreviewRequest($inboundPreviewRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\InboundPreview200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\InboundPreview200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\InboundPreview200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\InboundPreview200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\InboundPreview200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation inboundPreviewAsync
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inboundPreviewAsync(
        \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest
    ): PromiseInterface {
        return $this->inboundPreviewAsyncWithHttpInfo($inboundPreviewRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inboundPreviewAsyncWithHttpInfo
     *
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function inboundPreviewAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\InboundPreview200Response';
        $request = $this->inboundPreviewRequest($inboundPreviewRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'inboundPreview'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inboundPreviewRequest(
        \Walmart\Model\MP\US\Fulfillment\InboundPreviewRequest $inboundPreviewRequest,
    ): Request {
        $contentType = self::contentTypes['inboundPreview'];

        // verify the required parameter 'inboundPreviewRequest' is set
        if ($inboundPreviewRequest === null || (is_array($inboundPreviewRequest) && count($inboundPreviewRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inboundPreviewRequest when calling inboundPreview'
            );
        }
        $resourcePath = '/v3/fulfillment/inbound-preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($inboundPreviewRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($inboundPreviewRequest));
            } else {
                $httpBody = $inboundPreviewRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation printCarrierLabel
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    public function printCarrierLabel(
        string $shipmentId,
        \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        return $this->printCarrierLabelWithHttpInfo($shipmentId, $printCarrierLabelRequest);
    }

    /**
     * Operation printCarrierLabelWithHttpInfo
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    protected function printCarrierLabelWithHttpInfo(
        string $shipmentId,
        \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest,
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        $request = $this->printCarrierLabelRequest($shipmentId, $printCarrierLabelRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation printCarrierLabelAsync
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function printCarrierLabelAsync(
        string $shipmentId,
        \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest
    ): PromiseInterface {
        return $this->printCarrierLabelAsyncWithHttpInfo($shipmentId, $printCarrierLabelRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation printCarrierLabelAsyncWithHttpInfo
     *
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function printCarrierLabelAsyncWithHttpInfo(
        string $shipmentId,
        \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
        $request = $this->printCarrierLabelRequest($shipmentId, $printCarrierLabelRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'printCarrierLabel'
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function printCarrierLabelRequest(
        string $shipmentId,
        \Walmart\Model\MP\US\Fulfillment\PrintCarrierLabelRequest $printCarrierLabelRequest,
    ): Request {
        $contentType = self::contentTypes['printCarrierLabel'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling printCarrierLabel'
            );
        }
        // verify the required parameter 'printCarrierLabelRequest' is set
        if ($printCarrierLabelRequest === null || (is_array($printCarrierLabelRequest) && count($printCarrierLabelRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $printCarrierLabelRequest when calling printCarrierLabel'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-label/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($printCarrierLabelRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($printCarrierLabelRequest));
            } else {
                $httpBody = $printCarrierLabelRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation promiseFulfillments
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response
     */
    public function promiseFulfillments(
        \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest
    ): \Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response {
        return $this->promiseFulfillmentsWithHttpInfo($promiseFulfillmentsRequest);
    }

    /**
     * Operation promiseFulfillmentsWithHttpInfo
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response
     */
    protected function promiseFulfillmentsWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest,
    ): \Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response {
        $request = $this->promiseFulfillmentsRequest($promiseFulfillmentsRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation promiseFulfillmentsAsync
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function promiseFulfillmentsAsync(
        \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest
    ): PromiseInterface {
        return $this->promiseFulfillmentsAsyncWithHttpInfo($promiseFulfillmentsRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation promiseFulfillmentsAsyncWithHttpInfo
     *
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function promiseFulfillmentsAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\PromiseFulfillments200Response';
        $request = $this->promiseFulfillmentsRequest($promiseFulfillmentsRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'promiseFulfillments'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function promiseFulfillmentsRequest(
        \Walmart\Model\MP\US\Fulfillment\PromiseFulfillmentsRequest $promiseFulfillmentsRequest,
    ): Request {
        $contentType = self::contentTypes['promiseFulfillments'];

        // verify the required parameter 'promiseFulfillmentsRequest' is set
        if ($promiseFulfillmentsRequest === null || (is_array($promiseFulfillmentsRequest) && count($promiseFulfillmentsRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $promiseFulfillmentsRequest when calling promiseFulfillments'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments/fetchOrderPromiseOptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($promiseFulfillmentsRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($promiseFulfillmentsRequest));
            } else {
                $httpBody = $promiseFulfillmentsRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShipmentQuantity
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    public function updateShipmentQuantity(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        return $this->updateShipmentQuantityWithHttpInfo($updateShipmentQuantityRequest);
    }

    /**
     * Operation updateShipmentQuantityWithHttpInfo
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    protected function updateShipmentQuantityWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest,
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        $request = $this->updateShipmentQuantityRequest($updateShipmentQuantityRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation updateShipmentQuantityAsync
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShipmentQuantityAsync(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest
    ): PromiseInterface {
        return $this->updateShipmentQuantityAsyncWithHttpInfo($updateShipmentQuantityRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShipmentQuantityAsyncWithHttpInfo
     *
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function updateShipmentQuantityAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
        $request = $this->updateShipmentQuantityRequest($updateShipmentQuantityRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShipmentQuantity'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShipmentQuantityRequest(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantityRequest $updateShipmentQuantityRequest,
    ): Request {
        $contentType = self::contentTypes['updateShipmentQuantity'];

        // verify the required parameter 'updateShipmentQuantityRequest' is set
        if ($updateShipmentQuantityRequest === null || (is_array($updateShipmentQuantityRequest) && count($updateShipmentQuantityRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateShipmentQuantityRequest when calling updateShipmentQuantity'
            );
        }
        $resourcePath = '/v3/fulfillment/shipment-quantities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateShipmentQuantityRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateShipmentQuantityRequest));
            } else {
                $httpBody = $updateShipmentQuantityRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShipmentTrackingDetails
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    public function updateShipmentTrackingDetails(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        return $this->updateShipmentTrackingDetailsWithHttpInfo($updateShipmentTrackingDetailsRequest);
    }

    /**
     * Operation updateShipmentTrackingDetailsWithHttpInfo
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    protected function updateShipmentTrackingDetailsWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest,
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        $request = $this->updateShipmentTrackingDetailsRequest($updateShipmentTrackingDetailsRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation updateShipmentTrackingDetailsAsync
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShipmentTrackingDetailsAsync(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest
    ): PromiseInterface {
        return $this->updateShipmentTrackingDetailsAsyncWithHttpInfo($updateShipmentTrackingDetailsRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShipmentTrackingDetailsAsyncWithHttpInfo
     *
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function updateShipmentTrackingDetailsAsyncWithHttpInfo(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
        $request = $this->updateShipmentTrackingDetailsRequest($updateShipmentTrackingDetailsRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShipmentTrackingDetails'
     *
     * @param  \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShipmentTrackingDetailsRequest(
        \Walmart\Model\MP\US\Fulfillment\UpdateShipmentTrackingDetailsRequest $updateShipmentTrackingDetailsRequest,
    ): Request {
        $contentType = self::contentTypes['updateShipmentTrackingDetails'];

        // verify the required parameter 'updateShipmentTrackingDetailsRequest' is set
        if ($updateShipmentTrackingDetailsRequest === null || (is_array($updateShipmentTrackingDetailsRequest) && count($updateShipmentTrackingDetailsRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateShipmentTrackingDetailsRequest when calling updateShipmentTrackingDetails'
            );
        }
        $resourcePath = '/v3/fulfillment/shipment-tracking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateShipmentTrackingDetailsRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateShipmentTrackingDetailsRequest));
            } else {
                $httpBody = $updateShipmentTrackingDetailsRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation voidCarrierRateQuote
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    public function voidCarrierRateQuote(
        string $shipmentId
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        return $this->voidCarrierRateQuoteWithHttpInfo($shipmentId);
    }

    /**
     * Operation voidCarrierRateQuoteWithHttpInfo
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    protected function voidCarrierRateQuoteWithHttpInfo(
        string $shipmentId,
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        $request = $this->voidCarrierRateQuoteRequest($shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation voidCarrierRateQuoteAsync
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidCarrierRateQuoteAsync(
        string $shipmentId
    ): PromiseInterface {
        return $this->voidCarrierRateQuoteAsyncWithHttpInfo($shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voidCarrierRateQuoteAsyncWithHttpInfo
     *
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function voidCarrierRateQuoteAsyncWithHttpInfo(
        string $shipmentId,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
        $request = $this->voidCarrierRateQuoteRequest($shipmentId, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'voidCarrierRateQuote'
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voidCarrierRateQuoteRequest(
        string $shipmentId,
    ): Request {
        $contentType = self::contentTypes['voidCarrierRateQuote'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling voidCarrierRateQuote'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quote/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wercsFeedback
     *
     * Hazmat Items On hold
     *
     * @param  string $accept Only supported Media Type : application/json (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    public function wercsFeedback(
        string $accept,
        \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        return $this->wercsFeedbackWithHttpInfo($accept, $wercsFeedbackRequest);
    }

    /**
     * Operation wercsFeedbackWithHttpInfo
     *
     * Hazmat Items On hold
     *
     * @param  string $accept Only supported Media Type : application/json (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response
     */
    protected function wercsFeedbackWithHttpInfo(
        string $accept,
        \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest,
    ): \Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response {
        $request = $this->wercsFeedbackRequest($accept, $wercsFeedbackRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response', $response->getHeaders());
            }

            $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation wercsFeedbackAsync
     *
     * Hazmat Items On hold
     *
     * @param  string $accept Only supported Media Type : application/json (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wercsFeedbackAsync(
        string $accept,
        \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest
    ): PromiseInterface {
        return $this->wercsFeedbackAsyncWithHttpInfo($accept, $wercsFeedbackRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wercsFeedbackAsyncWithHttpInfo
     *
     *
     * Hazmat Items On hold
     *
     * @param  string $accept Only supported Media Type : application/json (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function wercsFeedbackAsyncWithHttpInfo(
        string $accept,
        \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Model\MP\US\Fulfillment\UpdateShipmentQuantity200Response';
        $request = $this->wercsFeedbackRequest($accept, $wercsFeedbackRequest, );
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'wercsFeedback'
     *
     * @param  string $accept Only supported Media Type : application/json (required)
     * @param  \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function wercsFeedbackRequest(
        string $accept,
        \Walmart\Model\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest,
    ): Request {
        $contentType = self::contentTypes['wercsFeedback'];

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling wercsFeedback'
            );
        }
        // verify the required parameter 'wercsFeedbackRequest' is set
        if ($wercsFeedbackRequest === null || (is_array($wercsFeedbackRequest) && count($wercsFeedbackRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wercsFeedbackRequest when calling wercsFeedback'
            );
        }
        $resourcePath = '/v3/items/onhold/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wercsFeedbackRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wercsFeedbackRequest));
            } else {
                $httpBody = $wercsFeedbackRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }
}

