<?php

/**
 * InternationalShippingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 */

/**
 * International Shipping
 *
 * This class is auto-generated by the OpenAPI generator v6.6.0 (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace Walmart\Apis\MP\CA;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use Walmart\Apis\BaseApi;
use Walmart\ApiException;
use Walmart\ObjectSerializer;

/**
 * InternationalShippingApi Class Doc Comment
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 * @email    jesse@highsidelabs.co
 */
class InternationalShippingApi extends BaseApi
{
    /**
     * @var string[] $contentTypes
     */
    public const contentTypes = [
        'createConsolidation' => 'application/json',
        'createLabel' => 'application/json',
        'discardLabel' => 'application/json',
        'getCarrierPackageTypes' => 'application/json',
        'getCarriers' => 'application/json',
        'getConsolidation' => 'application/json',
        'getLabel' => 'application/json',
        'getLabelByTrackingAndCarrier' => 'application/json',
    ];

    /**
     * Operation createConsolidation
     *
     * Create consolidation
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest Consolidation Request (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse
     */
    public function createConsolidation(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse {
        return $this->createConsolidationWithHttpInfo($accept, $contentType, $consolidationRequest);
    }

    /**
     * Operation createConsolidationWithHttpInfo
     *
     * Create consolidation
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest Consolidation Request (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse
     */
    protected function createConsolidationWithHttpInfo(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest,
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse {
        $request = $this->createConsolidationRequest($accept, $contentType, $consolidationRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createConsolidationAsync
     *
     * Create consolidation
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest Consolidation Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConsolidationAsync(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest
    ): PromiseInterface {
        return $this->createConsolidationAsyncWithHttpInfo($accept, $contentType, $consolidationRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConsolidationAsyncWithHttpInfo
     *
     * Create consolidation
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest Consolidation Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createConsolidationAsyncWithHttpInfo(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse';
        $request = $this->createConsolidationRequest($accept, $contentType, $consolidationRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConsolidation'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest Consolidation Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createConsolidationRequest(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\ConsolidationRequest $consolidationRequest,
    ): Request {
        $contentType = self::contentTypes['createConsolidation'];

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling createConsolidation'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling createConsolidation'
            );
        }
        // verify the required parameter 'consolidationRequest' is set
        if ($consolidationRequest === null || (is_array($consolidationRequest) && count($consolidationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consolidationRequest when calling createConsolidation'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels/shipment/international/consolidation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($consolidationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($consolidationRequest));
            } else {
                $httpBody = $consolidationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createLabel
     *
     * Create label
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa Label fields (required)
     * @param  bool $wMTESTMODE For sellers/clients who are in the process of on boarding or already on boarded to IMD platforms, this feature allows them to test the API integration to SWW international label generation API. Sellers get a response which maps their request attributes with some additional static information like tracking and label. The label returned is corresponding to the carrier configured for each seller, in case if the configuration is still in progress a sample Fedex Express label is returned. (optional, default to false)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa
     */
    public function createLabel(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa,
        ?bool $wMTESTMODE = false
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa {
        return $this->createLabelWithHttpInfo($accept, $contentType, $labelGenerationRequestCa, $wMTESTMODE);
    }

    /**
     * Operation createLabelWithHttpInfo
     *
     * Create label
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa Label fields (required)
     * @param  bool $wMTESTMODE For sellers/clients who are in the process of on boarding or already on boarded to IMD platforms, this feature allows them to test the API integration to SWW international label generation API. Sellers get a response which maps their request attributes with some additional static information like tracking and label. The label returned is corresponding to the carrier configured for each seller, in case if the configuration is still in progress a sample Fedex Express label is returned. (optional, default to false)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa
     */
    protected function createLabelWithHttpInfo(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa,
        ?bool $wMTESTMODE = false,
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa {
        $request = $this->createLabelRequest($accept, $contentType, $labelGenerationRequestCa, $wMTESTMODE);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createLabelAsync
     *
     * Create label
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa Label fields (required)
     * @param  bool $wMTESTMODE For sellers/clients who are in the process of on boarding or already on boarded to IMD platforms, this feature allows them to test the API integration to SWW international label generation API. Sellers get a response which maps their request attributes with some additional static information like tracking and label. The label returned is corresponding to the carrier configured for each seller, in case if the configuration is still in progress a sample Fedex Express label is returned. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createLabelAsync(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa,
        ?bool $wMTESTMODE = false
    ): PromiseInterface {
        return $this->createLabelAsyncWithHttpInfo($accept, $contentType, $labelGenerationRequestCa, $wMTESTMODE)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createLabelAsyncWithHttpInfo
     *
     * Create label
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa Label fields (required)
     * @param  bool $wMTESTMODE For sellers/clients who are in the process of on boarding or already on boarded to IMD platforms, this feature allows them to test the API integration to SWW international label generation API. Sellers get a response which maps their request attributes with some additional static information like tracking and label. The label returned is corresponding to the carrier configured for each seller, in case if the configuration is still in progress a sample Fedex Express label is returned. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createLabelAsyncWithHttpInfo(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa,
        ?bool $wMTESTMODE = false,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa';
        $request = $this->createLabelRequest($accept, $contentType, $labelGenerationRequestCa, $wMTESTMODE);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createLabel'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     * @param  \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa Label fields (required)
     * @param  bool $wMTESTMODE For sellers/clients who are in the process of on boarding or already on boarded to IMD platforms, this feature allows them to test the API integration to SWW international label generation API. Sellers get a response which maps their request attributes with some additional static information like tracking and label. The label returned is corresponding to the carrier configured for each seller, in case if the configuration is still in progress a sample Fedex Express label is returned. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createLabelRequest(
        string $accept,
        string $contentType,
        \Walmart\Models\MP\CA\InternationalShipping\LabelGenerationRequestCa $labelGenerationRequestCa,
        ?bool $wMTESTMODE = false,
    ): Request {
        $contentType = self::contentTypes['createLabel'];

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling createLabel'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling createLabel'
            );
        }
        // verify the required parameter 'labelGenerationRequestCa' is set
        if ($labelGenerationRequestCa === null || (is_array($labelGenerationRequestCa) && count($labelGenerationRequestCa) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $labelGenerationRequestCa when calling createLabel'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // header params
        if ($wMTESTMODE !== null) {
            $headerParams['WM.TEST_MODE'] = ObjectSerializer::toHeaderValue($wMTESTMODE);
        }
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($labelGenerationRequestCa)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($labelGenerationRequestCa));
            } else {
                $httpBody = $labelGenerationRequestCa;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discardLabel
     *
     * Discard label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa
     */
    public function discardLabel(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa {
        return $this->discardLabelWithHttpInfo($carrierShortName, $trackingNo, $accept, $contentType);
    }

    /**
     * Operation discardLabelWithHttpInfo
     *
     * Discard label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa
     */
    protected function discardLabelWithHttpInfo(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType,
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa {
        $request = $this->discardLabelRequest($carrierShortName, $trackingNo, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation discardLabelAsync
     *
     * Discard label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discardLabelAsync(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType
    ): PromiseInterface {
        return $this->discardLabelAsyncWithHttpInfo($carrierShortName, $trackingNo, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discardLabelAsyncWithHttpInfo
     *
     * Discard label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function discardLabelAsyncWithHttpInfo(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseLabelGenerationResponseCa';
        $request = $this->discardLabelRequest($carrierShortName, $trackingNo, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'discardLabel'
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function discardLabelRequest(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType,
    ): Request {
        $contentType = self::contentTypes['discardLabel'];

        // verify the required parameter 'carrierShortName' is set
        if ($carrierShortName === null || (is_array($carrierShortName) && count($carrierShortName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $carrierShortName when calling discardLabel'
            );
        }
        // verify the required parameter 'trackingNo' is set
        if ($trackingNo === null || (is_array($trackingNo) && count($trackingNo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingNo when calling discardLabel'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling discardLabel'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling discardLabel'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels/carriers/{carrierShortName}/trackings/{trackingNo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'DELETE';

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($carrierShortName !== null) {
            $resourcePath = str_replace(
                '{' . 'carrierShortName' . '}',
                ObjectSerializer::toPathValue($carrierShortName),
                $resourcePath
            );
        }
        if ($trackingNo !== null) {
            $resourcePath = str_replace(
                '{' . 'trackingNo' . '}',
                ObjectSerializer::toPathValue($trackingNo),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarrierPackageTypes
     *
     * Supported carrier package types
     *
     * @param  string $carrierShortName carrierShortName received from getCarrier API or pass 'ALL' to fetch all supported package types of different carriers (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse
     */
    public function getCarrierPackageTypes(
        string $carrierShortName,
        string $accept,
        string $contentType
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse {
        return $this->getCarrierPackageTypesWithHttpInfo($carrierShortName, $accept, $contentType);
    }

    /**
     * Operation getCarrierPackageTypesWithHttpInfo
     *
     * Supported carrier package types
     *
     * @param  string $carrierShortName carrierShortName received from getCarrier API or pass 'ALL' to fetch all supported package types of different carriers (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse
     */
    protected function getCarrierPackageTypesWithHttpInfo(
        string $carrierShortName,
        string $accept,
        string $contentType,
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse {
        $request = $this->getCarrierPackageTypesRequest($carrierShortName, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getCarrierPackageTypesAsync
     *
     * Supported carrier package types
     *
     * @param  string $carrierShortName carrierShortName received from getCarrier API or pass 'ALL' to fetch all supported package types of different carriers (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierPackageTypesAsync(
        string $carrierShortName,
        string $accept,
        string $contentType
    ): PromiseInterface {
        return $this->getCarrierPackageTypesAsyncWithHttpInfo($carrierShortName, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarrierPackageTypesAsyncWithHttpInfo
     *
     * Supported carrier package types
     *
     * @param  string $carrierShortName carrierShortName received from getCarrier API or pass 'ALL' to fetch all supported package types of different carriers (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getCarrierPackageTypesAsyncWithHttpInfo(
        string $carrierShortName,
        string $accept,
        string $contentType,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListCarrierPackageResponse';
        $request = $this->getCarrierPackageTypesRequest($carrierShortName, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarrierPackageTypes'
     *
     * @param  string $carrierShortName carrierShortName received from getCarrier API or pass 'ALL' to fetch all supported package types of different carriers (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarrierPackageTypesRequest(
        string $carrierShortName,
        string $accept,
        string $contentType,
    ): Request {
        $contentType = self::contentTypes['getCarrierPackageTypes'];

        // verify the required parameter 'carrierShortName' is set
        if ($carrierShortName === null || (is_array($carrierShortName) && count($carrierShortName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $carrierShortName when calling getCarrierPackageTypes'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getCarrierPackageTypes'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getCarrierPackageTypes'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels/carriers/{carrierShortName}/package-types';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($carrierShortName !== null) {
            $resourcePath = str_replace(
                '{' . 'carrierShortName' . '}',
                ObjectSerializer::toPathValue($carrierShortName),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarriers
     *
     * Supported carriers
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse
     */
    public function getCarriers(
        string $accept,
        string $contentType
    ): \Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse {
        return $this->getCarriersWithHttpInfo($accept, $contentType);
    }

    /**
     * Operation getCarriersWithHttpInfo
     *
     * Supported carriers
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse
     */
    protected function getCarriersWithHttpInfo(
        string $accept,
        string $contentType,
    ): \Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse {
        $request = $this->getCarriersRequest($accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getCarriersAsync
     *
     * Supported carriers
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarriersAsync(
        string $accept,
        string $contentType
    ): PromiseInterface {
        return $this->getCarriersAsyncWithHttpInfo($accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarriersAsyncWithHttpInfo
     *
     * Supported carriers
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getCarriersAsyncWithHttpInfo(
        string $accept,
        string $contentType,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CarrierCommonResponseListCarrierResponse';
        $request = $this->getCarriersRequest($accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarriers'
     *
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarriersRequest(
        string $accept,
        string $contentType,
    ): Request {
        $contentType = self::contentTypes['getCarriers'];

        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getCarriers'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getCarriers'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels/carriers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsolidation
     *
     * Get consolidation details
     *
     * @param  string $domesticTrackingNo Domestic TrackingNo. (required)
     * @param  int $domesticCarrierId Domestic CarrierId. (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse
     */
    public function getConsolidation(
        string $domesticTrackingNo,
        int $domesticCarrierId,
        string $accept,
        string $contentType
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse {
        return $this->getConsolidationWithHttpInfo($domesticTrackingNo, $domesticCarrierId, $accept, $contentType);
    }

    /**
     * Operation getConsolidationWithHttpInfo
     *
     * Get consolidation details
     *
     * @param  string $domesticTrackingNo Domestic TrackingNo. (required)
     * @param  int $domesticCarrierId Domestic CarrierId. (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse
     */
    protected function getConsolidationWithHttpInfo(
        string $domesticTrackingNo,
        int $domesticCarrierId,
        string $accept,
        string $contentType,
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse {
        $request = $this->getConsolidationRequest($domesticTrackingNo, $domesticCarrierId, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getConsolidationAsync
     *
     * Get consolidation details
     *
     * @param  string $domesticTrackingNo Domestic TrackingNo. (required)
     * @param  int $domesticCarrierId Domestic CarrierId. (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsolidationAsync(
        string $domesticTrackingNo,
        int $domesticCarrierId,
        string $accept,
        string $contentType
    ): PromiseInterface {
        return $this->getConsolidationAsyncWithHttpInfo($domesticTrackingNo, $domesticCarrierId, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsolidationAsyncWithHttpInfo
     *
     * Get consolidation details
     *
     * @param  string $domesticTrackingNo Domestic TrackingNo. (required)
     * @param  int $domesticCarrierId Domestic CarrierId. (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getConsolidationAsyncWithHttpInfo(
        string $domesticTrackingNo,
        int $domesticCarrierId,
        string $accept,
        string $contentType,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseConsolidationResponse';
        $request = $this->getConsolidationRequest($domesticTrackingNo, $domesticCarrierId, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsolidation'
     *
     * @param  string $domesticTrackingNo Domestic TrackingNo. (required)
     * @param  int $domesticCarrierId Domestic CarrierId. (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConsolidationRequest(
        string $domesticTrackingNo,
        int $domesticCarrierId,
        string $accept,
        string $contentType,
    ): Request {
        $contentType = self::contentTypes['getConsolidation'];

        // verify the required parameter 'domesticTrackingNo' is set
        if ($domesticTrackingNo === null || (is_array($domesticTrackingNo) && count($domesticTrackingNo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domesticTrackingNo when calling getConsolidation'
            );
        }
        // verify the required parameter 'domesticCarrierId' is set
        if ($domesticCarrierId === null || (is_array($domesticCarrierId) && count($domesticCarrierId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domesticCarrierId when calling getConsolidation'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getConsolidation'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getConsolidation'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels/shipment/international/consolidation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $domesticTrackingNo,
                'domesticTrackingNo', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $domesticCarrierId,
                'domesticCarrierId', // param base name
                'integer', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
        );

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLabel
     *
     * Labels by purchase order id
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa
     */
    public function getLabel(
        string $purchaseOrderId,
        string $accept,
        string $contentType
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa {
        return $this->getLabelWithHttpInfo($purchaseOrderId, $accept, $contentType);
    }

    /**
     * Operation getLabelWithHttpInfo
     *
     * Labels by purchase order id
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa
     */
    protected function getLabelWithHttpInfo(
        string $purchaseOrderId,
        string $accept,
        string $contentType,
    ): \Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa {
        $request = $this->getLabelRequest($purchaseOrderId, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getLabelAsync
     *
     * Labels by purchase order id
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLabelAsync(
        string $purchaseOrderId,
        string $accept,
        string $contentType
    ): PromiseInterface {
        return $this->getLabelAsyncWithHttpInfo($purchaseOrderId, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLabelAsyncWithHttpInfo
     *
     * Labels by purchase order id
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getLabelAsyncWithHttpInfo(
        string $purchaseOrderId,
        string $accept,
        string $contentType,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\CA\InternationalShipping\CommonResponseListLabelGenerationResponseCa';
        $request = $this->getLabelRequest($purchaseOrderId, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLabel'
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLabelRequest(
        string $purchaseOrderId,
        string $accept,
        string $contentType,
    ): Request {
        $contentType = self::contentTypes['getLabel'];

        // verify the required parameter 'purchaseOrderId' is set
        if ($purchaseOrderId === null || (is_array($purchaseOrderId) && count($purchaseOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderId when calling getLabel'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getLabel'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getLabel'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels/purchase-orders/{purchaseOrderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($purchaseOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'purchaseOrderId' . '}',
                ObjectSerializer::toPathValue($purchaseOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLabelByTrackingAndCarrier
     *
     * Download label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getLabelByTrackingAndCarrier(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType
    ): \SplFileObject {
        return $this->getLabelByTrackingAndCarrierWithHttpInfo($carrierShortName, $trackingNo, $accept, $contentType);
    }

    /**
     * Operation getLabelByTrackingAndCarrierWithHttpInfo
     *
     * Download label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    protected function getLabelByTrackingAndCarrierWithHttpInfo(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType,
    ): \SplFileObject {
        $request = $this->getLabelByTrackingAndCarrierRequest($carrierShortName, $trackingNo, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\SplFileObject', $response->getHeaders());
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getLabelByTrackingAndCarrierAsync
     *
     * Download label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLabelByTrackingAndCarrierAsync(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType
    ): PromiseInterface {
        return $this->getLabelByTrackingAndCarrierAsyncWithHttpInfo($carrierShortName, $trackingNo, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLabelByTrackingAndCarrierAsyncWithHttpInfo
     *
     * Download label
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getLabelByTrackingAndCarrierAsyncWithHttpInfo(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType,
    ): PromiseInterface {
        $returnType = '\SplFileObject';
        $request = $this->getLabelByTrackingAndCarrierRequest($carrierShortName, $trackingNo, $accept, $contentType);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLabelByTrackingAndCarrier'
     *
     * @param  string $carrierShortName carrierShortName from getCarriers API (required)
     * @param  string $trackingNo trackingNo (required)
     * @param  string $accept Accept Header (required)
     * @param  string $contentType Content-Type Header (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLabelByTrackingAndCarrierRequest(
        string $carrierShortName,
        string $trackingNo,
        string $accept,
        string $contentType,
    ): Request {
        $contentType = self::contentTypes['getLabelByTrackingAndCarrier'];

        // verify the required parameter 'carrierShortName' is set
        if ($carrierShortName === null || (is_array($carrierShortName) && count($carrierShortName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $carrierShortName when calling getLabelByTrackingAndCarrier'
            );
        }
        // verify the required parameter 'trackingNo' is set
        if ($trackingNo === null || (is_array($trackingNo) && count($trackingNo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingNo when calling getLabelByTrackingAndCarrier'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling getLabelByTrackingAndCarrier'
            );
        }
        // verify the required parameter 'contentType' is set
        if ($contentType === null || (is_array($contentType) && count($contentType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contentType when calling getLabelByTrackingAndCarrier'
            );
        }
        $resourcePath = '/v3/ca/shipping/labels/carriers/{carrierShortName}/trackings/{trackingNo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }
        if ($contentType !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($contentType);
        }

        // path params
        if ($carrierShortName !== null) {
            $resourcePath = str_replace(
                '{' . 'carrierShortName' . '}',
                ObjectSerializer::toPathValue($carrierShortName),
                $resourcePath
            );
        }
        if ($trackingNo !== null) {
            $resourcePath = str_replace(
                '{' . 'trackingNo' . '}',
                ObjectSerializer::toPathValue($trackingNo),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $channelTypeSchemeApiKey = $this->config->getApiKey('channelTypeScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($channelTypeSchemeApiKey !== null) {
            $headers['WM_CONSUMER.CHANNEL.TYPE'] = $channelTypeSchemeApiKey;
        }

        $signatureSchemeApiKey = $this->config->getApiKey('signatureScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($signatureSchemeApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureSchemeApiKey;
        }

        $consumerIdSchemeApiKey = $this->config->getApiKey('consumerIdScheme', [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_TIMESTAMP'],
        ]);
        if ($consumerIdSchemeApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdSchemeApiKey;
        }

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }
}

